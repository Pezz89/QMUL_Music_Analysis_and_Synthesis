\documentclass[titlepage]{scrartcl}
\usepackage{enumitem}
\usepackage[british]{babel}
\usepackage[style=apa, backend=biber]{biblatex}
\DeclareLanguageMapping{british}{british-apa}
\usepackage{url}
\usepackage{float}
\usepackage[labelformat=empty]{caption}
\restylefloat{table}
\usepackage{perpage}
\MakePerPage{footnote}
\usepackage{abstract}
\usepackage{graphicx}
% Create hyperlinks in bibliography
\usepackage{hyperref}
\usepackage{amsmath}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{blindtext}
\setkomafont{disposition}{\normalfont\bfseries}

\graphicspath{
    {./resources/},
}
\addbibresource{~/Documents/library.bib}

\newsavebox{\abstractbox}
\renewenvironment{abstract}
  {\begin{lrbox}{0}\begin{minipage}{\textwidth}
   \begin{center}\normalfont\sectfont\abstractname\end{center}\quotation}
  {\endquotation\end{minipage}\end{lrbox}%
   \global\setbox\abstractbox=\box0 }

\usepackage{etoolbox}
\makeatletter
\expandafter\patchcmd\csname\string\maketitle\endcsname
  {\vskip\z@\@plus3fill}
  {\vskip\z@\@plus2fill\box\abstractbox\vskip\z@\@plus1fill}
  {}{}
\makeatother

\DeclareCiteCommand{\citeyearpar}
    {}
    {\mkbibparens{\bibhyperref{\printdate}}}
    {\multicitedelim}
    {}

% MATLAB Code block stuff...
\usepackage{color}
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}

\lstset{language=Matlab,
   keywords={break,case,catch,continue,else,elseif,end,for,function,
      global,if,otherwise,persistent,return,switch,try,while},
   basicstyle=\ttfamily,
   keywordstyle=\color{blue},
   commentstyle=\color{gray},
   stringstyle=\color{dkgreen},
   numbers=left,
   numberstyle=\tiny\color{gray},
   stepnumber=1,
   numbersep=10pt,
   backgroundcolor=\color{white},
   tabsize=4,
   showspaces=false,
   showstringspaces=false}

\begin{document}
\title{ECS731U/P --- Music Analysis and Synthesis}
\subtitle{\LARGE{Assignment 3 Report}}
\author{Sam Perry --- EC16039}

\maketitle

\section{Task Solution}
The approach to this task consisted of the extraction of relevant features from
the audio, the estimation of stable sections from these features, the
refinement of segment boundaries and finally, the synthesis of the output audio
based on the best segment found.

\subsection{Feature extraction}
Three features were chosen to provide as measure for the overall stability of
the audio at any time in the audio. These features are fundamental frequency
($f_0$), Root Mean Square and Spectral Flux.\\
Spectral flux, used for measuring salience of spectral content, was calculated as:
$$
\text{SF}(n) =
\frac{\sqrt{\sum_{K/2-1}^{k=0}(|X(k,n)|-|X(k,n-1)|)^2}}{K/2}
$$
where $X$ represents the DFT of the audio, $K$ is the current DFT bin index, $K$ is
the total number of bins and $n$ is the current sample
index~\parencite{Lerch2012}.\\
RMS was chosen as a simple measure for loudness and was calculated as:
$$RMS(n) = \sqrt{\frac{1}{N}\sum_{i=i_s(n)}^{i_e(n)}{x(i)^2}}$$
where $i$ represents indexes in the current frame of audio and N is the total
number of indexes in the current frame~\parencite{Lerch2012}..

An implementation of the YIN algorithm was adapted for fundamental frequency
estimation~\parencite[p352-353]{Zolzer2011}. This implementation was further
modified to use parabolic interpolation for increased accuracy.
It was also noticed that as the system would only be analysing audio of
specific, relatively static pitches, it was not necessary to differentiate
between different octaves. For this reason, the $f_0$ was wrapped and centred
using the chroma spectrum. This allowed for the negation of octave errors
commonly seen in auto-correlation based $f_0$ estimation algorithms:
$$ Insert math here...$$
This significantly improved the measurement of pitch spread as discussed in
the following section.

see figure~\ref{} for illustration of loop
selection based on these features.
\subsection{Feature analysis/loop selection}
A moving standard deviation was then taken for each of the three features,
creating 3 vectors to measure the spread of these features over time.
An iteratively increasing threshold was applied to the standard deviation
measurements, searching for segments of consecutive frames to be used for
looping. A frame was considered viable if it's length was greater than it's
mean fundamental period multiplied by the minimum number of periods set as a
parameter. 
Upon finding a suitable frame, positive zero crossings are searched for around
it's starting index and the closest multiple to the mean f0 period at the end
point. These values form the final start and end indexes for the loop.

\subsection{Synthesis}
Output is then synthesized by segmenting the audio into three sections (start,
loop and end) and inserting an integer number of loops in place of
the loop segment found. The number of loops inserted is calculated based on the
duration provided in samples, and the closest number of loops to the desired
overall length of the sample is used.
Initially a method using overlap-add with crossfading was tested, however, this
was not used because amplitude modulation detracted from overall quality


\section{Evaluation}
minimum period proved to be the primary parameter used for tuning the system.
Low values resulted in the selection of smaller loops, with less variation in
content over time. Too small and the loop would sound synthetic without
variation. High values resulted in larger loops with more variation. Hiigher
variation clearly sounded more natural but increased the chance of
dicontinuities due to sudden changes at loop points. careful splicing of
samples at zero crossings made sure there were no clicks at loop points (see
figure~\ref{} for illustartion of segmentation at zero crossings) but
long samples will evolve over time, thus inheriantly not looping well.
a reasonable value of 25 periods was found to provide a good trade off between
these two charachteristics.
A range of audio files were tested using the system. Each was stretched by a
duration of 1.5 time it's origonal duration. This was the only duration tested
significantly as the system is not designed to handle anything less than the
original duration of the sample and further duration would simply add more
loops.
vibrato a key problem with cello. multiples of the vobrato's period as well as
the frequency would need to be selected for better handeling on this. 
Vocal vibrato performed possibly the worst. This was entirely expected as
statically looping audio with such temporal variation will resulted in clearly
unatural results.
Instruments with the least variation such as the trumpet and tombone appeared
to perform best, with only minor variations in amplitude missing from the
looped section.

\subsection{Possible improvements}
searching for start/end of periods
output duration isn't sample accurate
Gradient ascent could be applied for accurate and more efficient calculation
of thresholds for audio segmentation.

handeling of vibrato

\section{Figures}

\printbibliography

\end{document}
